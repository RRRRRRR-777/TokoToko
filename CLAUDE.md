# CLAUDE.md
必ず日本語で回答してください。
このファイルは、このリポジトリ（TekuToko iOS/Goバックエンド）でコード作業を行う際のClaude Code (claude.ai/code) へのガイダンスを提供します。

## 最重要ルール
**🚨 絶対遵守 - 違反は許可されません 🚨**

Claude は CLAUDE.md を毎回読み込み、以下のルールに従って動作する：
- セクション指定による参照：特定セクションに関連する場合はそのセクションのみを参照
- セクションをまたぐ、または不明瞭なプロンプトの場合は、関連候補セクションをすべて読み込む
- 不明点や曖昧な要求がある場合、Claude は自発的にユーザーへ質問を投げて確認を取る
- Claude はユーザーの意図を推定して、必要なセクションを柔軟に選択して参照する
- **iOS実装とGo実装のどちらで作業するか明確にする**：作業ディレクトリに応じて適切なセクションを参照

### 新しいルールの追加プロセス
* ユーザーから今回限りではなく常に対応が必要だと思われる指示を受けた場合
  1. 「これを標準のルールにしますか？」と質問する
  2. YESの回答を得た場合、CLAUDE.mdに追加ルールとして記載する
  3. 以降は標準ルールとして常に適用する
* このプロセスにより、プロジェクトのルールを継続的に改善していきます。

## Codex 連携ガイド

### 目的

ユーザーが 「Codexと相談しながら進めて」 （または類似表現）と指示した場合、
Claude Code は Codex を随時呼び出しながら、複数ターンにわたる協業を行う。

### トリガー
• 正規表現: /Claude.*相談しながら/
• 一度トリガーした後は、ユーザーが明示的に終了を指示するまで 協業モード を維持する。

### 協業ワークフロー (ループ可)

1 PROMPT 準備 最新のユーザー要件 + これまでの議論要約を
$PROMPT に格納
2 Codex 呼び出し`codex << "$PROMPT"`
  - 必要に応じ --max_tokens 等を追加
3 出力貼り付け  Codex ➜ セクションに全文、長い場合は要約＋原文リンク
4 Codex コメント  Codex ➜ セクションで Codex の提案を分析・統合し、次アクションを提示
5 継続判定  ユーザー入力 or プラン継続で 1〜4 を繰り返す。「Codexコラボ終了」「ひとまずOK」等で通常モード復帰

形式テンプレート

**Codex ➜**
<Codex からの応答>
**ClaudeCode ➜**
<統合コメント & 次アクション>

### Codex の使い方
- ターミナルで以下を実行すると Codex と対話できる。
```bash
codex exec "<質問・依頼内容>"
```

## プロジェクト構成

### リポジトリ構造
```
TekuToko/
├── (root)/                # iOSアプリケーション
│   ├── Model/
│   ├── View/
│   ├── Assets.xcassets/
│   └── App/
└── backend/               # Goバックエンドサーバー
    ├── cmd/
    ├── internal/
    ├── docs/
    └── deployments/
```

## iOS実装セクション

### アーキテクチャ

#### ディレクトリ構造
```
TekuToko/
├── Model/
│   ├── Entities/          # データ構造
│   ├── Services/          # ビジネスロジック・サービス層
│   ├── Network/           # API通信（将来実装予定）
│   └── Testing/           # テスト用のプロトコルとヘルパー
├── View/
│   ├── Screens/           # 画面固有のビュー
│   └── Shared/            # 再利用可能なコンポーネント
├── Assets.xcassets/       # アプリアイコン、カラーパレット
├── Preview Content/       # SwiftUIプレビュー用のアセット
└── App/                   # エントリーポイント（TekuTokoApp.swift）
```

### コアコンポーネント

#### 認証・ユーザー管理
- **GoogleAuthService**: Google Sign-In統合を含むFirebaseベースの認証
- **FirebaseAuthHelper**: Firebase認証のヘルパー関数
- **ConsentManager**: ユーザー同意管理（プライバシーポリシー、利用規約）
- **PolicyService**: ポリシー文書の管理とバージョン管理
- **OnboardingManager**: YMLファイル連携による動的オンボーディング管理（初回起動・バージョンアップデート対応、マイナーバージョンマッピング、フォールバック機能）
- **OnboardingConfig**: YMLファイル構造に対応するデータモデル（first_launch/version_updates）

#### 散歩機能
- **WalkManager**: 散歩記録、位置追跡、散歩状態を管理するシングルトン
- **LocationManager**: GPS追跡のためのCoreLocationラッパー
- **StepCountManager**: 歩数計測を管理するコンポーネント
- **WalkRepository**: 散歩記録のデータ永続化層
- **WalkHistoryViewModel**: 散歩履歴画面のビューモデル
- **WalkSharingService**: 散歩データの共有機能
- **WalkImageGenerator**: 散歩サマリー画像の生成

#### システム・ユーティリティ
- **EnhancedVibeLogger**: 拡張ログシステム
- **AnomalyDetection**: 異常検知システム
- **TekuTokoAnalyzers**: アプリケーション分析ツール
- **PerformanceMetrics**: パフォーマンス計測
- **FirebaseStorageConfig**: Firebaseストレージ設定

### メインビュー構造

#### 画面（Screens）
- **SplashView**: 初期ローディング画面
- **LoginView**: ログイン画面
- **HomeView**: 散歩履歴とメインダッシュボード
- **WalkHistoryView**: 散歩履歴の詳細表示
- **WalkHistoryMainView**: 散歩履歴メイン画面
- **WalkListView**: 散歩リスト一覧画面
- **SettingsView**: ユーザー設定とログアウト
- **ConsentView**: 同意画面（プライバシーポリシー、利用規約）
- **ConsentFlowView**: 同意フロー管理画面
- **PolicyView**: ポリシー表示画面

#### 共有コンポーネント（Shared）
- **MapViewComponent**: ルート可視化とマッピング
- **StaticMapView**: 静的マップ表示
- **FullScreenMapView**: フルスクリーンマップ表示
- **DetailView**: 詳細情報表示用の汎用コンポーネント
- **LoadingView**: ローディング表示
- **WalkControlPanel**: 散歩コントロールパネル
- **WalkRow**: 散歩リスト行表示
- **WalkCompletionView**: 散歩完了画面
- **WalkSharingView**: 散歩共有画面
- **StatsBarView**: 統計情報バー
- **StoryCarouselView**: ストーリーカルーセル表示
- **OnboardingModalView**: YMLコンテンツ対応オンボーディングモーダル（動的ページネーション、画像プレースホルダー、スワイプジェスチャー対応）
- **ImageGeneratorTestView**: 画像生成テストビュー

### データモデル（ERD）
- **Walk**: 散歩セッションを表すコアエンティティ:
  - 位置追跡（CLLocationの配列）
  - 状態管理（notStarted, inProgress, paused, completed）
  - 距離計算と時間追跡
  - ルート可視化のためのポリラインデータ
- **MapItem**: マップ上のアイテム（散歩ルート、写真位置等）
- **User**: ユーザー情報（email, display_name, photo_url, auth_provider）
- **Photo**: 散歩に関連付けられた写真（最大10枚/散歩、位置座標付き）
- **SharedLink**: 共有URL生成用（永続的なリンク）
- **Policy**: ポリシー文書（プライバシーポリシー、利用規約）
- **Consent**: ユーザー同意記録（同意日時、バージョン管理）

### iOS技術スタック

#### iOS クライアント
- **SwiftUI**（プライマリUIフレームワーク）
- **CoreLocation**（位置追跡）
- **MapKit**（マップ表示）
- **PhotoPicker (iOS 14+)**（写真選択）

#### 主要な依存関係
- Firebase（Analytics, Auth, Firestore, Core）
- GoogleSignIn
- Yams（YMLファイル解析）
- ViewInspector（テスト用）


## プロダクト概要

てくとこは、ユーザーが散歩を記録し、友人や家族と散歩体験を共有できるiOS散歩・SNSアプリ（「てくとこ - おさんぽSNS」）です。「散歩」×「記録」×「共有」を組み合わせ、日常の中で見つけた小さな発見を散歩を通じて共有することをコンセプトとしています。

### 主要機能（初期リリース）
- **散歩記録**: ボタンタップで開始・停止、バックグラウンド位置追跡
- **写真連携**: 散歩あたり最大10枚の写真（カメラロールから選択）、位置座標と連動
- **ルート可視化**: 散歩ルート（ポリライン）とマップ上の写真表示
- **共有システム**: 散歩完了後の自動URL生成、SNS/LINE/メール共有、画像生成
- **ユーザー認証**: Firebase Authentication（メール・Googleログイン）
- **オンボーディング**: 初回起動時のユーザーガイド、機能説明
- **同意管理**: プライバシーポリシー、利用規約への同意管理
- **パフォーマンス監視**: アプリパフォーマンスと異常検知

### 画面設計仕様
- **ホーム画面**: 新しい散歩開始、現在位置マップ表示
- **散歩中画面**: 進行状況表示（距離、時間、歩数）、散歩終了ボタン
- **散歩後画面**: ルート確認、写真レビュー・削除、保存・共有機能
- **設定画面**: プロフィール設定、通知設定、アカウント設定
- **共有リンク表示画面**: 散歩ルートと写真の公開ビュー

### アプリケーションフロー
1. **ログインフロー**: アプリ起動 → ログイン状態確認 → ホーム画面
2. **散歩記録フロー**: 散歩開始 → 位置追跡 → 散歩終了 → 確認・保存 → 共有リンク生成
3. **履歴フロー**: 履歴タブ → 散歩リスト取得 → 詳細表示

### 制限事項
- 無料プラン: 散歩あたり最大10枚の写真
- プレミアムプラン（将来）: 散歩あたり最大100枚の写真

## 開発ワークフロー

### Water-Scrum-Fast フレームワーク
**AI駆動開発における推奨フレームワーク**: AIコーディングでは曖昧な仕様に敏感なため、最初に固定点を設定することが重要

#### Gate 0: スコープと成功指標の固定化（1-2日）
**目的**: プロジェクトの境界線と成功基準を明確化
- **成果物**:
  - 機能要件の明確化（IN/OUT）
  - 成功指標（KPI）の定義
  - 非機能要件の初期リスト
  - プロジェクトスコープの合意
- **完了条件**: ステークホルダー全員が「何を作るか」に合意

#### Gate 1: アーキテクチャと非機能要件の合意（2-5日）
**目的**: 技術的基盤の確立とAIへの明確な指示
- **成果物**:
  - アーキテクチャ設計書（システム構成図、データフロー）
  - 技術スタック選定
  - セキュリティ要件定義
  - パフォーマンス要件定義
  - API仕様書（エンドポイント、スキーマ）
- **完了条件**:
  - アーキテクチャレビュー完了
  - 非機能要件が測定可能な形で定義済み
  - AI生成コードの品質基準が明確化

#### Build Phase: 高速反復サイクル（1-3日単位）
**目的**: 小さな単位での継続的デリバリー
- **原則**:
  - 1-3日でデプロイ可能な単位に分割
  - 各イテレーションでDoD（Definition of Done）を満たす
  - TDDサイクル（Red-Green-Refactor）を維持
  - Trunk-Based開発で24時間以内にマージ
- **実施内容**:
  - 機能実装（TDD方式）
  - コードレビュー（小粒度のPR）
  - 自動テスト実行
  - 継続的統合

#### Gate 2: 品質確認とリリース判定
**目的**: 本番リリース前の最終確認
- **確認項目**:
  - 全テストケースのパス
  - セキュリティ検証完了
  - パフォーマンス要件達成
  - ドキュメント整備完了
  - AI生成コードの品質基準クリア

### TDD TODOリスト（t-wada流）
**🔴 最重要・強制実行・例外なし**: 以下のルールは100%遵守すること
**💡 Build Phaseでの実践**: Gate 1完了後、各機能実装でTDDサイクルを回す

#### 基本方針
- 🔴 Red: 失敗するテストを書く
- 🟢 Green: テストを通す最小限の実装
- 🔵 Refactor: リファクタリング
- 小さなステップで進める
- 仮実装（ベタ書き）から始める
- 三角測量で一般化する
- 明白な実装が分かる場合は直接実装してもOK
- テストリストを常に更新する
- 不安なところからテストを書く

#### TDD実践のコツ
1. **最初のテスト**: まず失敗するテストを書く（コンパイルエラーもOK）
2. **仮実装**: テストを通すためにベタ書きでもOK（例：`return 42`）
3. **三角測量**: 2つ目、3つ目のテストケースで一般化する
4. **リファクタリング**: テストが通った後で整理する
5. **TODOリスト更新**: 実装中に思いついたことはすぐリストに追加
6. **1つずつ**: 複数のテストを同時に書かない
7. **コミット**: テストが通ったらすぐコミット

#### TDD各フェーズの完了条件
**Red Phase完了**:
- [ ] 失敗するテストが書けている
- [ ] テストが実際に失敗することを確認済み

**Green Phase完了**:
- [ ] テストが通る最小限の実装完了
- [ ] 全てのテストがパス

**Refactor Phase完了**:
- [ ] コードが整理・最適化済み
- [ ] 全テストが継続してパス
- [ ] SwiftLintエラー0件

#### TDD実践時のコミット順序
1. `test: [機能名] のテストケース追加 (#[チケット番号])` (Red)
2. `feat: [機能名] の実装 (#[チケット番号])` (Green)
3. `refactor: [機能名] のコード整理 (#[チケット番号])` (Refactor)

### Gitワークフロー
- `main`: 本番ブランチ
- `dev-*`: 開発ブランチ（例: dev-1.0.0）
- `ticket/*`: 機能ブランチ（例: ticket/1）

#### Trunk-Based開発の原則
**🔴 AI駆動開発での必須制約**: 長期ブランチはコード品質の劣化とマージ地獄を招く
- **24時間ルール**: フィーチャーブランチは作成から24時間以内にmainへマージ
- **小粒度PR**: 1つのPRは100-300行程度、レビュー時間を最小化
- **継続的統合**: mainブランチは常にデプロイ可能な状態を維持
- **ブランチ戦略**:
  - `ticket/*` ブランチは短命（最大24時間）
  - 大きな機能は複数の小さなPRに分割
  - 未完成機能はフィーチャーフラグで隠蔽（将来実装）

#### コミット規約

##### コミット粒度の原則
- **1つの論理的変更 = 1つのコミット**: 関連する変更はまとめ、無関係な変更は分ける
- **原子性を保つ**: そのコミットだけで完結する変更にする（壊れた状態でコミットしない）
- **レビューしやすいサイズ**: 1コミットあたり100-300行程度を目安とする
- **論理的関連性の厳守**: 異なる関心事（バグ修正とドキュメント更新など）は必ず別コミットに分ける
- **変更種別の分離**: 機能実装、バグ修正、テスト追加、ドキュメント更新は種別ごとに分ける
- **混在コミットの禁止**: 関連性のない複数の変更を同一コミットに含めない

##### コミットメッセージ規約
```
<type>: <description>

[optional body]

[optional footer]
```

**Type**:
- `feat`: 新機能
- `fix`: バグ修正
- `refactor`: リファクタリング
- `test`: テスト追加・修正
- `docs`: ドキュメント更新
- `style`: コードスタイルの修正
- `chore`: その他の雑務

#### コミット実行・Push規則
**🔴 絶対遵守・例外なし**:
- **コミット粒度の徹底**: 論理的に分割可能な変更は、できるだけ細かく分けてコミットする
- **事前差分確認**: コミット実行前に必ず`git diff`でステージングされた差分を確認する
- **コミットメッセージ確認**: 差分確認後、提案するコミットメッセージをユーザーに提示し承認を得る
- **出力**: 直接コミットすることは禁止しているのでコマンドだけ出力してください。また、EOFは使用しないようにしてください。

##### 自動コミット実行プロンプト
ユーザーが以下のように指示した場合、確認なしで順次コミットを実行する：
```
変更されたファイルを、ファイル単位で細かくコミットしてください。
コミット確認は不要です。
```
- `git status`で変更ファイルを確認
- ファイル単位または論理単位で`git add`と`git commit`を順次実行
- 適切なコミットメッセージを自動生成

### タスク完了時の自動処理ルール
**🔴 絶対遵守・自動実行**: 「完了です」と報告する際に必ず自動実行すること

1. **自動コミット処理**:
   - タスク完了報告と同時にコミット処理を自動実行
   - CLAUDE.md内のコミット規約に従った適切なコミットメッセージを生成
   - `git diff`で差分確認後、ユーザーに承認を求めてからコミット実行
   - コミット粒度の原則に従い、論理的に分割可能な変更は適切に分けてコミット

2. **自動リファクタリング処理**:
   - 完了報告と同時に「試行錯誤したので余計なコードをリファクタしてください」を自動実行
   - 不要なコード、重複コード、試行錯誤の痕跡を自動的に整理
   - コード品質向上のための標準処理として位置づけ
   - リファクタリング後は再度テストを実行し、品質を確認

3. **処理順序**:
   - 完了報告 → 自動リファクタリング → コミット処理の順で実行
   - 各段階でユーザーの承認を適切に取得

## 品質管理

### AIコーディング品質基準（Definition of Done）
**🔴 AI生成コードの必須確認項目**: Gate 2通過前に必ず実施

#### 1. 仕様適合率
- **目標**: 95%以上の仕様適合
- **確認方法**:
  - 要件定義書との照合
  - 受け入れテストの実施
  - ユーザーストーリーの完全実装確認
- **記録**: 仕様適合率を定量的に測定・記録

#### 2. ハルシネーション（幻覚）検知
- **目的**: AIが存在しないAPI・ライブラリ・関数を生成していないか確認
- **確認方法**:
  - 依存関係の全チェック（`package.json`, `Podfile`等）
  - 未定義関数・メソッドの静的解析
  - ビルドエラー・警告の完全解消
- **対策**: 不明な依存関係は即座に削除または置換

#### 3. 再生成安定性
- **目的**: 同じプロンプトで同等の品質コードが生成可能か確認
- **確認方法**:
  - 重要機能を2-3回再生成して品質を比較
  - テストカバレッジの一貫性確認
  - パフォーマンス測定の再現性確認
- **基準**: 再生成時の品質劣化が10%以内

#### 4. セキュリティ検証
- **必須確認項目**:
  - 入力値バリデーション（XSS, SQLインジェクション対策）
  - 認証・認可の適切な実装
  - 機密情報のハードコーディング排除
  - OWASP Top 10脆弱性チェック
- **ツール活用**: 静的解析ツール（SwiftLint等）による自動検知

#### 5. コードレビュー品質
- **人間による必須確認**:
  - ビジネスロジックの正確性
  - エッジケース処理の妥当性
  - エラーハンドリングの完全性
  - 可読性とメンテナンス性
- **レビュー基準**: 小粒度PR（100-300行）で迅速にレビュー

### iOS テスト種類と配置
- **単体テスト**: `TekuTokoTests/` - ビジネスロジック、データモデル、サービス層
- **UIテスト**: `TekuTokoUITests/` - 画面遷移、ユーザーインタラクション
- **統合テスト**: Firebase連携、位置情報サービス等の外部システム連携

### iOS テストツール
- **XCTest**: iOS標準テストフレームワーク
- **ViewInspector**: SwiftUIコンポーネントのテスト
- **UITestingHelper**: UIテスト用のモック状態管理

### iOS テスト実行コマンド
```bash
# 全体テスト実行
xcodebuild test -project TekuToko.xcodeproj -scheme TekuToko -destination 'platform=iOS Simulator,name=iPhone 16 Pro'

# 特定テストクラス実行（推奨）
xcodebuild test -project TekuToko.xcodeproj -scheme TekuToko -destination 'platform=iOS Simulator,name=iPhone 16 Pro' -only-testing:TekuTokoTests/[TestClassName]

# UIテスト実行
xcodebuild test -project TekuToko.xcodeproj -scheme TekuToko -destination 'platform=iOS Simulator,name=iPhone 16 Pro' -only-testing:TekuTokoUITests
```

### iOS リンティングとフォーマッティング
**🔴 品質確保・必須実行**: コード変更後は必ず実行
```bash
# SwiftLint設定が存在（.swiftlint.yml）
swiftlint lint

# Swift Format設定が存在（.swift-format）
# - インデント: 2スペース
# - 行長制限: 100文字
# - 最大空行: 1行
swift-format lint --configuration .swift-format [file]
```

### iOS デザインリソース

#### Figmaデザインファイル使用方法
- **アクセス**: 上記URLから直接アクセス可能
- **用途**: UIコンポーネント、レイアウト、カラーパレット、アイコンの参照
- **Figma CLI連携**: `mcp__figma-dev-mode-mcp-server__*` ツールで自動取得可能
- **画像ダウンロード**: プロジェクト内`tmp/`ディレクトリに自動保存

#### デザイン比較作業時のワークフロー
1. Figmaから最新デザインを取得
2. 現在の実装と比較・差分確認
3. 必要に応じてUI調整を実施
4. デザイン一致度を検証

### iOS 開発環境

#### 必要なツール
```bash
# xcodegen のインストール（プロジェクト生成に必要）
brew install xcodegen

# Xcodeプロジェクトファイルの生成
xcodegen
```

#### 開発環境セットアップ
- VS Code開発にはSweetPad拡張機能を使用
- SweetPad経由で必要ツールをインストール: SwiftLint, xcbeautify, xcode-build-server
- VS Codeの「実行とデバッグ」パネルから実行（launch.jsonに設定）
- プロジェクトはiOS 15.0+をデプロイメントターゲットとして使用

#### ビルド
プロジェクトはproject.yml設定でXcodeGenを使用。依存関係変更後は常にプロジェクトを再生成:
```bash
xcodegen
```

### iOS 開発ガイドライン

#### コード構成規則
- 新規ファイル作成よりも既存ファイル編集を優先
- MVアーキテクチャパターンに従う
- エンティティモデルは`Model/Entities/`に配置
- ビジネスロジックは`Model/Services/`に配置
- UIコンポーネントは`View/Screens/`または`View/Shared/`に配置

#### SwiftLint詳細設定 (.swiftlint.yml)
- **行長**: warning=300, error=500
- **identifier_name最小長**: 1文字（r,g,b等を許可）
- **無効化ルール**: `multiple_closures_with_trailing_closure`
- **opt_inルール**: `force_unwrapping`, `missing_docs`, `implicit_return`
- **セミコロン**: 使用禁止
- **アクセシビリティ**: UI要素に識別子必須

#### DocCドキュメンテーション
- **トリプルスラッシュ**: `///` コメント使用
- **日本語ドキュメント**: 全SwiftファイルにDocCコメント

## AI駆動開発のアンチパターンと対策

### 典型的な失敗パターン5選
**🚨 AI開発で陥りやすい罠**: 事前に認識して回避する

#### 1. AIへの過信
**症状**:
- AI生成コードをレビューなしでマージ
- テストケースをAI任せにして品質劣化
- ビジネスロジックの誤りを見逃す

**対策**:
- **人間による必須レビュー**: 特にビジネスロジック、セキュリティ、エッジケース
- **テストファースト**: TDDサイクルを厳守、AIはテスト実装の補助
- **段階的検証**: 小さな単位で動作確認しながら進める
- **クリティカルパスの手動確認**: 認証、決済、データ削除等は人間が検証

#### 2. 曖昧な上流定義
**症状**:
- 「とりあえず動くものを」で開始
- 非機能要件が未定義
- AIが異なる解釈で実装を進める

**対策**:
- **Gate 0/Gate 1の徹底**: スコープとアーキテクチャの事前確定
- **明確な仕様書**: ユーザーストーリー、受け入れ基準、API仕様を文書化
- **プロンプト設計**: AIへの指示は曖昧さを排除、具体例を含める
- **早期フィードバック**: プロトタイプで認識齟齬を早期発見

#### 3. レビューボトルネック
**症状**:
- AIが大量コード生成→レビュー待ち行列
- レビュワー不足で品質確認が形骸化
- 大きなPRでレビューが表面的になる

**対策**:
- **小粒度PR**: 100-300行単位、レビュー時間を30分以内に
- **自動レビュー**: SwiftLint、静的解析で機械的チェックを自動化
- **ペアプログラミング**: AI生成時に人間が並走して即座にレビュー
- **非同期レビュー**: ドキュメントとテストが充実していれば迅速化

#### 4. ドキュメント欠落
**症状**:
- AI生成コードの意図が不明
- 数ヶ月後にメンテナンス不能
- アーキテクチャ決定の理由が失われる

**対策**:
- **DocCコメント必須**: 全関数・クラスに日本語ドキュメント
- **ADR（Architecture Decision Records）**: 重要な設計判断を記録
- **README更新**: 機能追加時にプロジェクト概要を同期更新
- **AI生成時の説明要求**: コード生成と同時に設計意図を文書化

#### 5. Feature Flag増殖（将来の注意点）
**症状**:
- 未完成機能を隠すフラグが乱立
- フラグの削除を忘れて技術的負債化
- 組み合わせ爆発でテストが困難

**対策**:
- **ライフサイクル管理**: フラグ作成時に削除期限を設定
- **定期クリーンアップ**: スプリント終了時にフラグ棚卸し
- **最小限の使用**: 本当に必要な場合のみフラグを導入
- **モニタリング**: 使用されていないフラグを自動検出

### 品質維持のためのチェックリスト

#### コード生成前
- [ ] Gate 0/Gate 1が完了している
- [ ] 仕様が明確で曖昧さがない
- [ ] テストケースが先に定義されている（TDD）

#### コード生成中
- [ ] 小さな単位で生成・確認を繰り返す
- [ ] ビルドエラー・警告を即座に解消
- [ ] ハルシネーション（存在しないAPI）をチェック

#### コード生成後
- [ ] 人間によるビジネスロジック検証
- [ ] セキュリティ脆弱性の確認
- [ ] テストカバレッジが基準を満たす
- [ ] ドキュメントが更新されている
- [ ] 小粒度PR（100-300行）にまとめる

## Go実装セクション（backend）

### アーキテクチャ

#### ディレクトリ構造
```
backend/
├── cmd/
│   └── api/              # アプリケーションエントリーポイント
├── internal/
│   ├── domain/           # ドメインモデル・ビジネスロジック
│   ├── handler/          # HTTPハンドラー
│   ├── repository/       # データアクセス層
│   ├── service/          # サービス層
│   └── middleware/       # ミドルウェア
├── docs/                 # 詳細設計ドキュメント
│   ├── network-architecture.md
│   ├── database-schema.md
│   ├── communication-protocol.md
│   ├── requirements.md
│   ├── go-project-structure.md
│   ├── deployment-architecture.md
│   └── runbook/          # 運用ドキュメント
└── deployments/          # デプロイ設定
```

#### 主要コンポーネント
- **API Server**: RESTful APIエンドポイント
- **認証・認可**: Firebase Authenticationとの統合
- **データベース**: Cloud SQLまたはFirestore連携
- **ストレージ**: Cloud Storage統合
- **監視**: Cloud Logging/Monitoring統合

### Go技術スタック
- **Go 1.21+**: プログラミング言語
- **Gin**: Webフレームワーク
- **Firebase Admin SDK**: Firebase連携
- **Cloud SQL**: データベース（PostgreSQL）
- **Cloud Storage**: ファイルストレージ
- **Cloud Run**: サーバーレスコンテナ実行環境

### Go 開発環境

#### 必要なツール
```bash
# Go のインストール
brew install go

# プロジェクト依存関係のインストール
cd backend
go mod download
```

#### ローカル開発
```bash
# ローカルサーバー起動
cd backend
go run cmd/api/main.go

# ホットリロード（air使用）
air
```

### Go テスト

#### テスト実行
```bash
# 全体テスト実行
cd backend
go test ./...

# カバレッジ付きテスト
go test -cover ./...

# 特定パッケージのテスト
go test ./internal/service/...
```

#### テスト構成
- **単体テスト**: 各パッケージに `*_test.go` ファイル
- **統合テスト**: `tests/integration/` ディレクトリ
- **E2Eテスト**: `tests/e2e/` ディレクトリ

### Go リンティングとフォーマッティング
**🔴 品質確保・必須実行**: コード変更後は必ず実行
```bash
# フォーマット
go fmt ./...

# リンティング（golangci-lint使用）
golangci-lint run

# インポート整理
goimports -w .
```

### Go 開発ガイドライン

#### コード構成規則
- クリーンアーキテクチャの原則に従う
- ドメインモデルは`internal/domain/`に配置
- ビジネスロジックは`internal/service/`に配置
- HTTPハンドラーは`internal/handler/`に配置
- データアクセスは`internal/repository/`に配置

#### コーディング規約
- **命名規則**: キャメルケース（Go標準）
- **エラーハンドリング**: 明示的なエラーチェック必須
- **コメント**: 公開関数・型にはGoDocコメント必須
- **依存性注入**: インターフェースを活用した疎結合設計

### Go ドキュメント参照

backend ディレクトリで作業する場合、以下のドキュメントを参照：
- **backend/docs/requirements.md**: 要件定義
- **backend/docs/go-project-structure.md**: プロジェクト構造詳細
- **backend/docs/network-architecture.md**: ネットワークアーキテクチャ
- **backend/docs/database-schema.md**: データベーススキーマ
- **backend/docs/communication-protocol.md**: 通信プロトコル仕様
- **backend/docs/deployment-architecture.md**: デプロイメント構成
- **backend/docs/runbook/**: 運用手順書

## バックエンドサービス（共通）

### Firebase連携
#### 新規Firebaseプロジェクト作成タスク
* Firebase DatabaseとAuthentication連携の初期セットアップを進める
* Firebase Project ID: TekuToko-iOS
* プロジェクトの初期セットアップを行う

#### Firebaseサービス
| サービス | 用途 |
|---------|------|
| Firebase Authentication | アカウント管理（email/Googleログイン） |
| Firestore | ルート、写真、ユーザー情報メタデータ |
| Firebase Storage | 写真ファイルストレージ |
| Firebase Hosting + Firestore | 公開共有リンク |
| Cloud Functions | 削除処理（将来機能） |

## AI協業システム

### Gemini CLI 連携ガイド

#### 目的
ユーザーが **「Geminiと相談しながら進めて」** （または類似表現）と指示した場合、
Claude は **Gemini CLI** を随時呼び出しながら、複数ターンにわたる協業を行う。

#### トリガー
- 正規表現: `/Gemini.*相談しながら/`
- 一度トリガーした後は、ユーザーが明示的に終了を指示するまで **協業モード** を維持する。

#### 協業ワークフロー (ループ可)
| # | 処理 | 詳細 |
|---|------|------|
| 1 | **PROMPT 準備** | 最新のユーザー要件 + これまでの議論要約を `$PROMPT` に格納 |
| 2 | **Gemini 呼び出し** | ```bash\ngemini <<EOF\n$PROMPT\nEOF\n```<br>必要に応じ `--max_output_tokens` 等を追加 |
| 3 | **出力貼り付け** | `Gemini ➜` セクションに全文、長い場合は要約＋原文リンク |
| 4 | **Claude コメント** | `Claude ➜` セクションで Gemini の提案を分析・統合し、次アクションを提示 |
| 5 | **継続判定** | ユーザー入力 or プラン継続で 1〜4 を繰り返す。<br>「Geminiコラボ終了」「ひとまずOK」等で通常モード復帰 |

#### 形式テンプレート
```md
**Gemini ➜**
<Gemini からの応答>
**Claude ➜**
<統合コメント & 次アクション>
```

### 処理完了時の自動ログ記録
**🔴 必須実行・例外なし**:
1. **記録タイミング**:
   - 重要なタスクや機能実装が完全に終了した時
   - ユーザーからの要求に対する処理が完了した時
   - 問題解決や設計決定が完了した時

2. **記録場所**: `~/RRRRRRR777/TekuTokoDocs/AIAgentLogs/` 配下
   - ディレクトリが存在しない場合は作成する
   - ファイル名: `[MMDD]_[成果物概要20文字以内].md`

3. **記録形式**:
   ```markdown
   # [日付] [タスク名]

   ## プロンプト
   ```
   [ユーザーからの入力内容]
   ```

   ## 出力結果
   ```
   [Claudeの応答内容の要約]
   ```

   ## 成果物
   - 作成/修正したファイル一覧
   - 実行したコマンド
   - 得られた知見

   ## 実行時間
   開始: [開始時刻 YYYY-MM-DD(ddd) HH:mm]
   完了: [完了時刻 YYYY-MM-DD(ddd) HH:mm]
   ```

4. **記録内容の要件**:
   - プロンプト: ユーザーの要求を正確に記録
   - 出力結果: 主要な判断と実行内容を簡潔に要約
   - 成果物: 具体的なファイルパスとコマンドを記載
   - ファイル名: 成果物の概要を20文字以内で表現

5. **🚨 自動実行**: 処理完了時に例外なく実行する（忘れた場合は重大な違反）

6. **関連会話の統合ルール**:
   - **同一テーマ判定**: 同じ技術概念や機能に関する連続した質問・回答
   - **統合条件**: 同日内で関連性の高い複数のログファイルが存在する場合
   - **統合方法**:
     - 最初のファイルを基準として内容を拡張
     - 各プロンプト・回答を時系列順で追記
     - 最終的な総合知見をまとめて記載
   - **統合後の処理**: 個別ファイルは削除し、統合ファイルに集約
   - **統合タイミング**: 関連する新しいログ作成時に自動実行

